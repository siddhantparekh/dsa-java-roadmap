<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive DSA Roadmap: Java Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chosen Palette: Calm Harmony (Light Beige, Stone Gray, Muted Teal) -->
    <!-- Application Structure Plan: An interactive dashboard with a collapsible accordion layout for topics and sub-topics. Key interactions include progress tracking via checklists, dynamic progress bars, and difficulty filtering. This structure is chosen to transform the static, linear document into a manageable, engaging, and goal-oriented learning tool, preventing user overwhelm and promoting focused study. -->
    <!-- Visualization & Content Choices: 
        - Roadmap Hierarchy -> Goal: Organize -> Viz/Method: Accordion Layout -> Interaction: Click to expand/collapse -> Justification: Provides better information architecture and reduces cognitive load compared to a long document.
        - Topic Progress -> Goal: Inform/Motivate -> Viz/Method: Dynamic Progress Bar (HTML/CSS/JS) -> Interaction: Automatically updates on user action -> Justification: Offers immediate, visual feedback on progress, which is highly motivating.
        - Question List -> Goal: Inform/Interact -> Viz/Method: Interactive Checklist -> Interaction: Click to mark as complete -> Justification: Enables active participation and clear tracking of completed tasks.
        - Question Difficulty -> Goal: Compare/Filter -> Viz/Method: Filter Buttons & Colored Badges -> Interaction: Click to filter displayed questions -> Justification: Allows for targeted learning sessions focused on a specific difficulty level.
        - Key Concepts -> Goal: Inform -> Viz/Method: Styled list with icons -> Interaction: Static display -> Justification: Clearly presents core patterns for each topic in an easily scannable format.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            background-color: #FDFBF5; /* A very light, warm beige */
            font-family: 'Inter', sans-serif;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        .progress-bar-bg {
            background-color: #EAE8E1; /* Muted background for progress bar */
        }
        .progress-bar-fg {
            background-color: #0d9488; /* Muted Teal */
            transition: width 0.5s ease-in-out;
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s cubic-bezier(0, 1, 0, 1);
        }
        .accordion-content.open {
            max-height: 5000px; /* Large enough for content */
            transition: max-height 1s ease-in-out;
        }
        .difficulty-badge {
            font-size: 0.7rem;
            padding: 0.1rem 0.5rem;
            border-radius: 9999px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .difficulty-easy { background-color: #dcfce7; color: #166534; }
        .difficulty-medium { background-color: #fef9c3; color: #854d0e; }
        .difficulty-hard { background-color: #fee2e2; color: #991b1b; }

        .filter-btn.active {
            background-color: #0d9488;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .question-item.completed label {
            text-decoration: line-through;
            color: #9ca3af;
        }
    </style>
</head>
<body class="text-stone-800">

    <div id="app" class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
        
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-stone-900">Interactive DSA Roadmap</h1>
            <p class="text-lg text-stone-600 mt-2">Master Data Structures & Algorithms with Java</p>
        </header>

        <div class="bg-white/60 backdrop-blur-sm rounded-2xl shadow-lg p-6 mb-8 sticky top-4 z-10">
            <h3 class="text-lg font-semibold mb-3 text-stone-700">Overall Progress</h3>
            <div class="progress-bar-bg w-full h-4 rounded-full overflow-hidden">
                <div id="overall-progress-bar" class="progress-bar-fg h-full rounded-full" style="width: 0%;"></div>
            </div>
            <div class="text-right mt-1 text-sm font-semibold text-stone-600">
                <span id="overall-progress-text">0 / 0</span> Questions Completed
            </div>
             <div id="filter-controls" class="mt-4 flex flex-wrap gap-2 justify-center">
                <button data-filter="all" class="filter-btn active px-4 py-1.5 text-sm font-medium rounded-full bg-stone-100 text-stone-700 hover:bg-stone-200 transition">All</button>
                <button data-filter="easy" class="filter-btn px-4 py-1.5 text-sm font-medium rounded-full bg-stone-100 text-stone-700 hover:bg-stone-200 transition">Easy</button>
                <button data-filter="medium" class="filter-btn px-4 py-1.5 text-sm font-medium rounded-full bg-stone-100 text-stone-700 hover:bg-stone-200 transition">Medium</button>
                <button data-filter="hard" class="filter-btn px-4 py-1.5 text-sm font-medium rounded-full bg-stone-100 text-stone-700 hover:bg-stone-200 transition">Hard</button>
            </div>
        </div>

        <main id="roadmap-container" class="space-y-4">
            <!-- Roadmap content will be generated by JavaScript -->
        </main>

    </div>

    <script>
        const roadmapData = [
            {
                id: 'fundamentals',
                title: 'I. Fundamentals',
                topics: [
                    { 
                        id: 'arrays', title: 'Arrays', 
                        description: "A collection of elements stored at contiguous memory locations. The most basic data structure.",
                        patterns: ["Two Pointers", "Sliding Window", "Prefix Sum", "Frequency Counting"],
                        questions: [
                            { name: "Two Sum", difficulty: "easy" },
                            { name: "Contains Duplicate", difficulty: "easy" },
                            { name: "Best Time to Buy and Sell Stock", difficulty: "easy" },
                            { name: "Move Zeroes", difficulty: "easy" },
                            { name: "Product of Array Except Self", difficulty: "medium" },
                            { name: "Maximum Subarray", difficulty: "medium" },
                            { name: "3Sum", difficulty: "medium" },
                            { name: "Container With Most Water", difficulty: "medium" },
                            { name: "Trapping Rain Water", difficulty: "hard" },
                            { name: "Median of Two Sorted Arrays", difficulty: "hard" },
                        ] 
                    },
                    {
                        id: 'strings', title: 'Strings',
                        description: "A sequence of characters, often treated as character arrays with special properties.",
                        patterns: ["Two Pointers", "Sliding Window", "Character Frequency", "String Builders"],
                        questions: [
                            { name: "Valid Palindrome", difficulty: "easy" },
                            { name: "Reverse String", difficulty: "easy" },
                            { name: "Valid Parentheses", difficulty: "easy" },
                            { name: "Group Anagrams", difficulty: "medium" },
                            { name: "Longest Substring Without Repeating Characters", difficulty: "medium" },
                            { name: "Longest Palindromic Substring", difficulty: "medium" },
                            { name: "Palindromic Substrings", difficulty: "medium" },
                            { name: "Minimum Window Substring", difficulty: "hard" },
                        ]
                    }
                ]
            },
            {
                id: 'linear',
                title: 'II. Linear Data Structures',
                topics: [
                    {
                        id: 'linked-lists', title: 'Linked Lists',
                        description: "A linear data structure where elements are linked using pointers, not stored contiguously.",
                        patterns: ["Traversal", "Dummy Node", "Two Pointers (Slow/Fast)", "Reversal"],
                        questions: [
                            { name: "Reverse Linked List", difficulty: "easy" },
                            { name: "Merge Two Sorted Lists", difficulty: "easy" },
                            { name: "Linked List Cycle", difficulty: "easy" },
                            { name: "Remove Nth Node From End of List", difficulty: "medium" },
                            { name: "Add Two Numbers", difficulty: "medium" },
                            { name: "Reorder List", difficulty: "medium" },
                            { name: "Copy List with Random Pointer", difficulty: "medium" },
                            { name: "Merge k Sorted Lists", difficulty: "hard" },
                            { name: "Reverse Nodes in k-Group", difficulty: "hard" },
                        ]
                    },
                    {
                        id: 'stacks', title: 'Stacks',
                        description: "A LIFO (Last-In, First-Out) data structure.",
                        patterns: ["LIFO Principle", "Matching Parentheses", "Monotonic Stack", "Expression Evaluation"],
                        questions: [
                            { name: "Valid Parentheses", difficulty: "easy" },
                            { name: "Min Stack", difficulty: "medium" },
                            { name: "Daily Temperatures", difficulty: "medium" },
                            { name: "Decode String", difficulty: "medium" },
                            { name: "Largest Rectangle in Histogram", difficulty: "hard" },
                        ]
                    },
                    {
                        id: 'queues', title: 'Queues',
                        description: "A FIFO (First-In, First-Out) data structure.",
                        patterns: ["FIFO Principle", "Breadth-First Search (BFS)", "Level Order Traversal"],
                        questions: [
                            { name: "Implement Stack using Queues", difficulty: "easy" },
                            { name: "Number of Recent Calls", difficulty: "easy" },
                            { name: "Design Circular Queue", difficulty: "medium" },
                            { name: "Rotting Oranges", difficulty: "medium" },
                        ]
                    }
                ]
            },
            {
                id: 'trees',
                title: 'III. Non-Linear Data Structures (Trees)',
                topics: [
                    {
                        id: 'binary-trees', title: 'Binary Trees',
                        description: "A hierarchical data structure where each node has at most two children.",
                        patterns: ["DFS (Pre-order, In-order, Post-order)", "BFS (Level Order)", "Recursion"],
                        questions: [
                            { name: "Maximum Depth of Binary Tree", difficulty: "easy" },
                            { name: "Same Tree", difficulty: "easy" },
                            { name: "Invert Binary Tree", difficulty: "easy" },
                            { name: "Subtree of Another Tree", difficulty: "easy" },
                            { name: "Binary Tree Level Order Traversal", difficulty: "medium" },
                            { name: "Lowest Common Ancestor of a Binary Tree", difficulty: "medium" },
                            { name: "Construct Binary Tree from Preorder and Inorder Traversal", difficulty: "medium" },
                            { name: "Binary Tree Right Side View", difficulty: "medium" },
                            { name: "Maximum Path Sum", difficulty: "hard" },
                            { name: "Serialize and Deserialize Binary Tree", difficulty: "hard" },
                        ]
                    },
                    {
                        id: 'bst', title: 'Binary Search Trees (BSTs)',
                        description: "A binary tree with an ordering property for efficient searching.",
                        patterns: ["BST Property", "In-order Traversal gives sorted", "Validation", "Successor/Predecessor"],
                        questions: [
                            { name: "Validate Binary Search Tree", difficulty: "medium" },
                            { name: "Kth Smallest Element in a BST", difficulty: "medium" },
                            { name: "Lowest Common Ancestor of a BST", difficulty: "easy" },
                            { name: "Delete Node in a BST", difficulty: "medium" },
                        ]
                    },
                    {
                        id: 'heaps', title: 'Heaps (Priority Queues)',
                        description: "A tree-based structure satisfying the heap property, for efficient min/max retrieval.",
                        patterns: ["Maintaining Order", "K-th Largest/Smallest", "Merging/Sorting"],
                        questions: [
                            { name: "Kth Largest Element in an Array", difficulty: "medium" },
                            { name: "Top K Frequent Elements", difficulty: "medium" },
                            { name: "Find Median from Data Stream", difficulty: "hard" },
                        ]
                    }
                ]
            },
            {
                id: 'graphs',
                title: 'IV. Graphs',
                topics: [
                    {
                        id: 'graph-traversals', title: 'Graph Representations & Traversals',
                        description: "A set of vertices and edges. Traversal involves visiting all nodes.",
                        patterns: ["Adjacency List/Matrix", "BFS", "DFS", "Topological Sort", "Cycle Detection"],
                        questions: [
                           { name: "Number of Islands", difficulty: "medium" },
                           { name: "Clone Graph", difficulty: "medium" },
                           { name: "Course Schedule", difficulty: "medium" },
                           { name: "Pacific Atlantic Water Flow", difficulty: "medium" },
                           { name: "Word Ladder", difficulty: "hard" },
                           { name: "Alien Dictionary", difficulty: "hard" },
                        ]
                    },
                ]
            },
            {
                id: 'algorithms',
                title: 'V. Algorithms',
                topics: [
                    {
                        id: 'dp', title: 'Dynamic Programming (DP)',
                        description: "An optimization technique for solving complex problems by breaking them down into simpler subproblems.",
                        patterns: ["Memoization (Top-down)", "Tabulation (Bottom-up)", "1D/2D DP", "Knapsack"],
                        questions: [
                            { name: "Climbing Stairs", difficulty: "easy" },
                            { name: "House Robber", difficulty: "medium" },
                            { name: "Coin Change", difficulty: "medium" },
                            { name: "Longest Increasing Subsequence", difficulty: "medium" },
                            { name: "Longest Common Subsequence", difficulty: "medium" },
                            { name: "Word Break", difficulty: "medium" },
                            { name: "Unique Paths", difficulty: "medium" },
                            { name: "Jump Game", difficulty: "medium" },
                            { name: "Edit Distance", difficulty: "hard" },
                            { name: "Best Time to Buy and Sell Stock with Cooldown", difficulty: "medium" },
                            { name: "Partition Equal Subset Sum", difficulty: "medium" },
                        ]
                    },
                    {
                        id: 'backtracking', title: 'Backtracking',
                        description: "An algorithmic technique for solving problems recursively by trying to build a solution incrementally.",
                        patterns: ["Decision Tree", "Choice, Constraints, Goal", "Permutations/Combinations"],
                        questions: [
                            { name: "Subsets", difficulty: "medium" },
                            { name: "Permutations", difficulty: "medium" },
                            { name: "Combination Sum", difficulty: "medium" },
                            { name: "Generate Parentheses", difficulty: "medium" },
                            { name: "Word Search", difficulty: "medium" },
                            { name: "N-Queens", difficulty: "hard" },
                        ]
                    },
                    {
                        id: 'greedy', title: 'Greedy Algorithms',
                        description: "Makes a locally optimal choice at each step with the hope of finding a global optimum.",
                        patterns: ["Local Optimal Choices", "Sorting", "Interval Scheduling"],
                        questions: [
                            { name: "Jump Game", difficulty: "medium" },
                            { name: "Gas Station", difficulty: "medium" },
                            { name: "Non-overlapping Intervals", difficulty: "medium" },
                            { name: "Minimum Number of Arrows to Burst Balloons", difficulty: "medium" },
                        ]
                    }
                ]
            }
        ];

        document.addEventListener('DOMContentLoaded', () => {
            const roadmapContainer = document.getElementById('roadmap-container');
            const state = { completed: new Set(), currentFilter: 'all' };

            const renderRoadmap = () => {
                roadmapContainer.innerHTML = '';
                let totalQuestions = 0;
                
                roadmapData.forEach(section => {
                    let sectionCompleted = 0;
                    let sectionTotal = 0;
                    
                    const sectionTopicsHTML = section.topics.map(topic => {
                        let topicCompleted = 0;
                        const topicTotal = topic.questions.length;
                        sectionTotal += topicTotal;
                        totalQuestions += topicTotal;

                        const questionsHTML = topic.questions.map(q => {
                            const questionId = `${topic.id}-${q.name.replace(/\s+/g, '-')}`;
                            const isCompleted = state.completed.has(questionId);
                            if (isCompleted) {
                                topicCompleted++;
                            }
                            const isVisible = state.currentFilter === 'all' || state.currentFilter === q.difficulty;

                            return `
                                <div class="question-item pl-6 py-2 flex items-center ${isCompleted ? 'completed' : ''}" style="${!isVisible ? 'display: none;' : ''}" data-difficulty="${q.difficulty}">
                                    <input type="checkbox" id="${questionId}" data-topic="${topic.id}" data-section="${section.id}" class="h-4 w-4 rounded border-gray-300 text-teal-600 focus:ring-teal-500" ${isCompleted ? 'checked' : ''}>
                                    <label for="${questionId}" class="ml-3 text-stone-700 flex-grow">${q.name}</label>
                                    <span class="difficulty-badge difficulty-${q.difficulty}">${q.difficulty}</span>
                                </div>
                            `;
                        }).join('');
                        
                        sectionCompleted += topicCompleted;

                        const patternsHTML = topic.patterns.map(p => `
                            <li class="flex items-center text-sm text-stone-600">
                                <span class="text-teal-600 mr-2">◆</span> ${p}
                            </li>
                        `).join('');

                        return `
                            <div class="bg-white rounded-lg overflow-hidden border border-stone-200/80 mb-3">
                                <header class="p-4 cursor-pointer flex justify-between items-center accordion-toggle bg-stone-50/50" data-target="#content-${topic.id}">
                                    <div>
                                        <h4 class="font-semibold text-stone-800">${topic.title}</h4>
                                        <p class="text-xs text-stone-500">${topic.description}</p>
                                    </div>
                                    <span class="text-xs font-semibold text-stone-600" id="progress-text-${topic.id}">${topicCompleted}/${topicTotal}</span>
                                </header>
                                <div class="accordion-content" id="content-${topic.id}">
                                    <div class="p-4 border-t border-stone-200">
                                        <h5 class="font-semibold text-sm mb-2 text-stone-700">Key Patterns & Concepts</h5>
                                        <ul class="space-y-1 mb-4">
                                            ${patternsHTML}
                                        </ul>
                                        <h5 class="font-semibold text-sm mb-2 text-stone-700">Practice Problems</h5>
                                        <div class="space-y-1">
                                            ${questionsHTML}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    const sectionHTML = `
                        <section id="${section.id}" class="bg-white/50 backdrop-blur-sm rounded-2xl shadow-md p-5">
                            <h2 class="text-2xl font-bold mb-4 text-stone-800">${section.title}</h2>
                            ${sectionTopicsHTML}
                        </section>
                    `;
                    roadmapContainer.innerHTML += sectionHTML;
                });
                
                updateOverallProgress();
            };

            const updateOverallProgress = () => {
                const allCheckboxes = document.querySelectorAll('input[type="checkbox"]');
                const total = allCheckboxes.length;
                const completedCount = state.completed.size;
                const percentage = total > 0 ? (completedCount / total) * 100 : 0;

                document.getElementById('overall-progress-bar').style.width = `${percentage}%`;
                document.getElementById('overall-progress-text').textContent = `${completedCount} / ${total}`;
            };
            
            const updateTopicProgress = (topicId) => {
                const topicCheckboxes = document.querySelectorAll(`#content-${topicId} input[type="checkbox"]`);
                const total = topicCheckboxes.length;
                let completedCount = 0;
                topicCheckboxes.forEach(cb => {
                    if (cb.checked) completedCount++;
                });
                 document.getElementById(`progress-text-${topicId}`).textContent = `${completedCount}/${total}`;
            }

            roadmapContainer.addEventListener('click', (e) => {
                if (e.target.matches('input[type="checkbox"]')) {
                    const id = e.target.id;
                    const topicId = e.target.dataset.topic;
                    if (e.target.checked) {
                        state.completed.add(id);
                        e.target.closest('.question-item').classList.add('completed');
                    } else {
                        state.completed.delete(id);
                        e.target.closest('.question-item').classList.remove('completed');
                    }
                    updateOverallProgress();
                    updateTopicProgress(topicId);
                }

                const accordionToggle = e.target.closest('.accordion-toggle');
                if (accordionToggle) {
                    const targetId = accordionToggle.dataset.target;
                    const content = document.querySelector(targetId);
                    content.classList.toggle('open');
                }
            });
            
            document.getElementById('filter-controls').addEventListener('click', (e) => {
                if(e.target.tagName === 'BUTTON') {
                    const filter = e.target.dataset.filter;
                    state.currentFilter = filter;
                    
                    document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');

                    document.querySelectorAll('.question-item').forEach(item => {
                        if (filter === 'all' || item.dataset.difficulty === filter) {
                            item.style.display = 'flex';
                        } else {
                            item.style.display = 'none';
                        }
                    });
                }
            });

            renderRoadmap();
        });
    </script>
</body>
</html>
